package org.wiredwidgets.cow.ac.client.ui;

import java.util.Date;
import javax.swing.BorderFactory;
import javax.swing.DefaultListModel;
import javax.swing.event.ListDataEvent;
import javax.swing.event.ListDataListener;
import org.wiredwidgets.cow.ac.client.controllers.TaskController;
import org.wiredwidgets.cow.ac.util.JSplitPaneThatWorks;
import org.wiredwidgets.cow.ac.client.utils.TaskListCellRenderer;
import org.wiredwidgets.cow.ac.util.server.BpmClientController;
import org.wiredwidgets.cow.server.api.service.Task;

/**
 * A panel displaying a decorated list of
 * <code>Tasks</code> available to the user. Details for a selected task are
 * displayed in a {@link TaskDetailsPanel}. This class is intimately tied to the {@link TaskController}.
 * <p/>
 * This class has a lot of half-baked UI features that could be improved or
 * never had time to be completed.
 *
 * @author RYANMILLER
 * @see TaskController
 */
public class TasksPanel extends javax.swing.JPanel {

    private StatusBar statusBar;
    private String DEFAULT_TASK_BORDER_TEXT;
    private TaskController tc;
    private Task lastSelectedTask;

    /**
     * Creates new form TasksPanel. The task list is tied to the model managed
     * by TaskListController.
     */
    public TasksPanel() {
        initComponents();

        tc = TaskController.getInstance();
        // ensure the taskcontroller is wired to refresh if the server connection settings update
        BpmClientController.getInstance().addSeverConnectionEventListener(tc);
        statusBar = StatusBar.getInstance();
        listTasks.setModel(tc.getTasksModel());
        tc.getTasksModel().addListDataListener(new TaskListDataListener());
        listTasks.addListSelectionListener(taskDetailsPanel);
        /* TODO - get task re-selection working so that if tasks are updated behind the
         * scenes (an available task was assigned, new info from the server,
         * etc) the user's selection is not lost. This proved much harder than I
         * would have thought. See the intervalAdded(), etc. methods below in
         * TaskListDataListener
         *
         * listTasks.addListSelectionListener( new ListSelectionListener() { //
         * store the last selected task @Override public void
         * valueChanged(ListSelectionEvent e) { if (!e.getValueIsAdjusting() &&
         * e.getSource() instanceof JList &&
         * ((JList)e.getSource()).getSelectionModel().getValueIsAdjusting() ==
         * false &&
         * ((JList)e.getSource()).getSelectionModel().getMinSelectionIndex() !=
         * -1) { lastSelectedTask =
         * (Task)((JList)e.getSource()).getSelectedValue();
         * System.out.println("set lst to " + lastSelectedTask.getId() + " " +
         * lastSelectedTask); System.out.flush(); } } });
         */

        DEFAULT_TASK_BORDER_TEXT = org.openide.util.NbBundle.getMessage(
                TasksPanel.class, "TasksPanel.tasksScrollPane.border.title");

        // can't set this in netbeans gui builder since it must be done at runtime, so we do it manually
        // with a hack
        JSplitPaneThatWorks.fixDividerLocation(jSplitPane1, 0.3);
    }

    /**
     * Refreshes the task count label based on the latest data in the model.
     */
    protected void updateTaskCountLabels() {
        // could make this much fancier to visually distinguish between assigned
        // and available tasks or indicate new tasks
        tasksScrollPane.setBorder(
                BorderFactory.createTitledBorder(
                DEFAULT_TASK_BORDER_TEXT
                + " (" + tc.getSpecializedTasksModel().getUserTaskCount() + " assigned, "
                + tc.getSpecializedTasksModel().getUnassignedTaskCount() + " available) "));
    }

    /** This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        topPanel = new javax.swing.JPanel();
        btnRefresh = new javax.swing.JButton();
        jSplitPane1 = new javax.swing.JSplitPane();
        tasksScrollPane = new javax.swing.JScrollPane();
        listTasks = new javax.swing.JList();
        taskDetailsPanel = new org.wiredwidgets.cow.ac.client.ui.TaskDetailsPanel();

        setLayout(new java.awt.BorderLayout());

        topPanel.setLayout(new java.awt.FlowLayout(java.awt.FlowLayout.LEFT, 10, 5));

        btnRefresh.setText(org.openide.util.NbBundle.getMessage(TasksPanel.class, "TasksPanel.btnRefresh.text")); // NOI18N
        btnRefresh.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnRefreshActionPerformed(evt);
            }
        });
        topPanel.add(btnRefresh);

        add(topPanel, java.awt.BorderLayout.PAGE_START);

        jSplitPane1.setBorder(null);
        jSplitPane1.setDividerLocation(175);
        jSplitPane1.setDividerSize(10);
        jSplitPane1.setResizeWeight(0.5);
        jSplitPane1.setContinuousLayout(true);
        jSplitPane1.setMinimumSize(new java.awt.Dimension(385, 133));

        tasksScrollPane.setBorder(javax.swing.BorderFactory.createTitledBorder(org.openide.util.NbBundle.getMessage(TasksPanel.class, "TasksPanel.tasksScrollPane.border.title"))); // NOI18N

        listTasks.setModel(new DefaultListModel()
        );
        listTasks.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION);
        listTasks.setCellRenderer(new TaskListCellRenderer());
        listTasks.setVisibleRowCount(4);
        tasksScrollPane.setViewportView(listTasks);

        jSplitPane1.setLeftComponent(tasksScrollPane);
        jSplitPane1.setRightComponent(taskDetailsPanel);

        add(jSplitPane1, java.awt.BorderLayout.CENTER);
    }// </editor-fold>//GEN-END:initComponents

    /**
     * Gets the tasks for the user defined in the preferences and loads them
     * into the task list
     *
     * @param evt
     */
    private void btnRefreshActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnRefreshActionPerformed

        statusBar.setStatusText("Updating tasks from server...");
        Date date = new Date();
        boolean updateSuccess = tc.refreshTasksFromServer();
        if (!updateSuccess) {
            // Sad face
            statusBar.setStatusText("Exception occured while updating tasks from the server.");
            // clear out existing info since we're not talking to the server and data may be stale
            tc.clearModelTasks();
            return;
        }

        statusBar.setStatusText("Tasks updated from server at " + date.toString());
        updateTaskCountLabels();
    }//GEN-LAST:event_btnRefreshActionPerformed
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton btnRefresh;
    private javax.swing.JSplitPane jSplitPane1;
    private javax.swing.JList listTasks;
    private org.wiredwidgets.cow.ac.client.ui.TaskDetailsPanel taskDetailsPanel;
    private javax.swing.JScrollPane tasksScrollPane;
    private javax.swing.JPanel topPanel;
    // End of variables declaration//GEN-END:variables

    ////////////////////////////////////////////////////////////////////////////
    /**
     * A very light-weight internal class that triggers some decorative UI
     * updates whenever the underlying list data model changes. Also watches for
     * the selected task to get removed (e.g. an available task is assigned.) If
     * it is re-added (via update from the server) (e.g. assigned to the user)
     * before another task is selected (by the user), the list will re-select
     * it.
     */
    class TaskListDataListener implements ListDataListener {

        @Override
        public void contentsChanged(ListDataEvent e) {
            //System.out.println("int changed called " + e.getIndex0() + ", " + e.getIndex1());
            //System.out.flush();
            updateTaskCountLabels();
        }

        // Gets called when elements are added to the model
        @Override
        public void intervalAdded(ListDataEvent e) {
            //System.out.println("int added called " + e.getIndex0() + ", " + e.getIndex1());
            //System.out.println("si: " + listTasks.getSelectedIndex());
            //System.out.println("ms: " + listTasks.getModel().getSize());
            //System.out.println("");
            //System.out.flush();
            updateTaskCountLabels();

            // TODO get working
            //if (listTasks.isSelectionEmpty() && lastSelectedTask != null) // reapply an old selection  
            //    reapplyListSelection(e.getIndex0(), e.getIndex1());
        }

        // Gets called when elements are removed from the model
        @Override
        public void intervalRemoved(ListDataEvent e) {
            //System.out.println("int removed called " + e.getIndex0() + ", " + e.getIndex1());
            //System.out.flush();
            updateTaskCountLabels();
        }
    }

    /**
     * Does not work as written.
     */
    private void reapplyListSelection(int i0, int i1) {
        if (lastSelectedTask == null) {
            return;
        }

        //System.out.println("Calling reapplySel [" + i0 + "," + i1 + "] with last task id of " + lastSelectedTask.getId());
        //System.out.flush();

        // search the updated model for the original task using i0 and i1 as bounds
        int newIndex = -1;
        //for (int i = i0; i < tc.getTasksModel().getSize() && i <= i1; i++) {
        for (int i = 0; i < tc.getTasksModel().getSize(); i++) {
            Task t = (Task) tc.getTasksModel().getElementAt(i);
            if (lastSelectedTask.getId().equals(t.getId())) {
                newIndex = i;
                //System.out.println("found an old selected task!");
                //System.out.flush();
                break;
            }
        }

        if (newIndex == -1) {
            //System.out.println("Last selected task " + lastSelectedTask.getId() + 
            //       " was not found in the current data model");
            //System.out.flush();
            return;
        }

        // convert the base model index into the correct index for the sorted model
        // and trigger selection
        //listTasks.setSelectedValue(tc.TasksModel().getElementAt(newIndex), true);
        //System.out.println("Would manually set selected task to " + ((Task)tc.getTasksModel().getElementAt(newIndex)).getId() + " at index " + newIndex);
        //System.out.flush();
        listTasks.setSelectedIndex(newIndex);

    }
}
